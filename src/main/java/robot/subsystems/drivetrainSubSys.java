// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.


package robot.subsystems;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.VictorSPXControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class drivetrainSubSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private VictorSPX leftFrontMotor;
private VictorSPX leftBackMotor;
private VictorSPX rightFrontMotor;
private VictorSPX rightBackMotor;
private DifferentialDrive frontDriveCtl;
private DifferentialDrive backDriveCtl;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // -------------- Drive Motor Current Limiting ---------------
    /**
     * Description:
     * The Current Limit example demonstrates the Talon's ability to perform current limiting.
     * The Current Limit Feature expands across 4 different functions:
     * 1.) configPeakCurrentLimit(), Config current threshold to trigger current limit
     * 2.) configPeakCurrentDuration(), Config duration after peak current to trigger current limit
     * 3.) configContinousCurrentLimit(), Config current to maintain after limit is triggered
     * 4.) enableCurrentLimit(bool enable), Enable/Disable Current Limiting on Talon
     *
     * This example has been configured to hold 10 Amps almost instantly after current
     * exceed peak current limit of 15 Amps.
     * 
     * 
     * Supported Version:
     * 	- Talon FX: 20.2.3.0
 */

    // Stator Limits
    static final boolean talonStatorLimit = false;
    static final double kStatorTriggerThresholdAmp = 30; 
    static final double kStatorTriggerThresholdTime = 1;
    static final double kStatorLimitAmp = 25;

    // Supply Limits
    static final boolean talonSupplyLimit = false;          // controls how much current the motor controllers can consume when at full load (boolean for on/off)
    static final double kSupplyTriggerThresholdAmp = 30; 
    static final double kSupplyTriggerThresholdTime = 0.5;
    static final double kSupplyLimitAmp = 25; 

    // Drive Motor Current Limiting Used in 2020 Robot with 3 motors on each side
    //private static final int DRIVE_MTR_MAX_PEAK_CURRENT = 25;    // Amps
    //private static final int DRIVE_MTR_MAX_PEAK_DURATION = 100;   // Milliseconds
    //private static final int DRIVE_MTR_MAX_CONT_CURRENT = 25;    // Amps
    //private static final boolean DRIVE_MTR_CURRENT_LIMIT_FLAG = true;
    // Example from CTRE 
    //                                                                  enabled | Limit(amp) | Trigger Threshold(amp) | Trigger Threshold Time(s)
    // motor.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(true,      20,                25,                1.0));
    // motor.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(true,      10,                15,                0.5));

    private static Timer driveTimer = new Timer();

    public drivetrainSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFrontMotor = new VictorSPX(4);

leftBackMotor = new VictorSPX(3);
 
rightFrontMotor = new VictorSPX(2);
 
rightBackMotor = new VictorSPX(1);


// driveCtrl = new DifferentialDrive()
// driveCtrl = new DifferentialDrive(leftMotorGrp, rightMotorGrp);
//  addChild("DriveCtrl",driveCtrl);
//  driveCtrl.setSafetyEnabled(true);
// driveCtrl.setExpiration(0.1);
// driveCtrl.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    leftFrontMotor.setInverted(true);
    leftBackMotor.setInverted(true);
    // leftMotorGrp.setInverted(true);

    /**
     * Configure the current limits that will be used
     * Stator Current is the current that passes through the motor stators.
     *  Use stator current limits to limit rotor acceleration/heat production
     * Supply Current is the current that passes into the controller from the supply
     *  Use supply current limits to prevent breakers from tripping
     * 
     * https://phoenix-documentation.readthedocs.io/en/latest/ch13_MC.html#current-limit
     * 
     *                                                                        enabled | Limit(amp) | Trigger Threshold(amp) | Trigger Threshold Time(s)  */
    /*
    //leftMotor1
    leftMotor1.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    leftMotor1.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //leftMotor2
    leftMotor2.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    leftMotor2.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //RightMotor1
    rightMotor1.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    rightMotor1.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    //RightMotor2
    rightMotor2.configStatorCurrentLimit(new StatorCurrentLimitConfiguration(talonStatorLimit, kStatorLimitAmp, kStatorTriggerThresholdAmp, kStatorTriggerThresholdTime));
    rightMotor2.configSupplyCurrentLimit(new SupplyCurrentLimitConfiguration(talonSupplyLimit, kSupplyLimitAmp, kSupplyTriggerThresholdAmp, kSupplyTriggerThresholdTime));
    */

    driveTimer.reset();
    driveTimer.start();
}

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void stop() {
        // driveCtrl.arcadeDrive(0, 0);
        leftFrontMotor.set(VictorSPXControlMode.PercentOutput, 0);
        leftBackMotor.set(VictorSPXControlMode.PercentOutput, 0);
        rightFrontMotor.set(VictorSPXControlMode.PercentOutput, 0);
        rightBackMotor.set(VictorSPXControlMode.PercentOutput, 0);
    }
    // public void curveDrive(double speed, double rotation, boolean inplace ){
    //     driveCtrl.curvatureDrive(speed, rotation, inplace);
    // }

    public void tankDrive(double leftSpeed, double rightSpeed){
        leftFrontMotor.set(VictorSPXControlMode.PercentOutput, leftSpeed);
        leftBackMotor.set(VictorSPXControlMode.PercentOutput, leftSpeed);
        rightFrontMotor.set(VictorSPXControlMode.PercentOutput, rightSpeed);
        rightBackMotor.set(VictorSPXControlMode.PercentOutput, rightSpeed);
    }

    public void arcadeDrive(double speed, double rotation){
        // calculate left and right motor values
        double leftMotorValue = speed + rotation;
        double rightMotorValue = speed - rotation;

        // ensure motor values are within -1 to 1 range
        if (leftMotorValue > 1) {
            leftMotorValue = 1;
        } else if (leftMotorValue < -1) {
            leftMotorValue = -1;
        }

        if (rightMotorValue > 1) {
            rightMotorValue = 1;
        } else if (rightMotorValue < -1) {
            rightMotorValue = -1;
        }

        tankDrive(leftMotorValue, rightMotorValue);
    }

}

